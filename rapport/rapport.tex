\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}

\title{DM COMP : Création d'un parseur d'expressions arithmétiques}
\author{Aurèle Barrière \& Antonin Garret}
\date{29 septembre 2016}

\begin{document}
\maketitle

\section{Introduction}
Le but de ce projet est d'implémenter un parseur d'expressions arithmétiques en \texttt{OCaml}, en utilisant les \texttt{stream parsers} de l'extension \texttt{Camlp4}. Le but est ainsi de convertir une chaîne de caractères (écrite sur un alphabet comportant des nombres et des opérateurs arithmétiques) en un arbre syntaxique abstrait donnant une représentation correcte (c'est-à-dire qui respecte les propriétés de priorité et d'associativité voulues) de l'expression.

On effectuera une analyse descendante.


Dans une première partie, nous verrons comment aboutir à une grammaire d'expressions arithmétiques prête à être implémentée. Ensuite, nous verrons comment l'implémenter. Enfin, nous nous intéresserons à la vérification empirique de notre implémentation.

\section{Une grammaire pour des expressions arithmétiques}

Pour implémenter notre parseur avec analyse descendante avec les \texttt{stream parsers}, il faut définir un ensemble de fonctions mutuellement récursives qui décomposent la chaîne de caractère souhaitée. Dans un premier temps, la chaîne de caractère aura été parcourue par un \textit{scanner} (ou \texttt{lexer}) qui repère les mot-clés (ou \texttt{tokens}), et qui convertit donc une chaîne de caractères en une chaîne de mot-clés.

Les fonctions mutuellement récursives prennent donc en entrée une chaîne de mot-clés, et renvoient un arbre syntaxique abstrait d'expression, qu'il nous faut définir. Une expression sera ainsi : un nombre ou une addition ou soustraction ou multplication ou division ou puissance de deux expressions. On aura donc en \texttt{Ocaml} : 
\begin{lstlisting} [breaklines=true]
type expr = Num of int | Add of expr * expr | Sub of expr * expr | Mul of expr * expr | Div of expr * expr | Pow of expr * expr 
\end{lstlisting}.


\subsection{Une première version}
Pour parser correctement des expressions arithmétiques dans lesquelles figurent l'addition, la soustraction, la multiplication et des parenthèses, en respectant les propriétés suivantes :
\begin{itemize}
\item L'addition, la soustraction et la multiplication sont associatives à gauche.
\item Les parenthèses sont priotitaires, puis la multiplication, puis l'addition (ou soustraction).
\end{itemize}

On dispose d'une première grammaire. Les récursivités gauches témoignent de l'associativité gauche des opérateurs. On a décomposé notre expressions en plusieurs sous-expressions : (E : expressions, F : facteurs, A : atomes) en suivant l'ordre inverse de priorité. Les dépendances cycliques entre ces différentes fonctions récursives nous obligeront à les déclarer comme des fonctions mutuellement récursives.

\begin{lstlisting}
E -> E + F | E - F | F
F -> F * A | A
A -> constante | ( E )
\end{lstlisting}

\subsection{Ajout de la division}
La division est un opérateur qui doit être associatif à gauche et avoir la même priorité que la multiplication. On ajoute donc la règle \texttt{F -> F / A}.
\begin{lstlisting}
E -> E + F | E - F | F
F -> F * A | F / A | A
A -> constante | ( E )
\end{lstlisting}

\subsection{Récursivités gauches}
Cependant, la méthode utilisée est l'analyse descendante. On ne peut donc pas garder nos règles avec récursivité gauche. Il faut donc créer de nouvelles règles pour les transformer en récursivités droites.

\begin{lstlisting}[escapeinside={!}{!}]
E     -> F E_aux
E_aux -> + F E_aux | - F E_aux | !$\epsilon$!
F     -> P F_aux
F_aux -> * A F_aux | / A F_aux | !$\epsilon$!
A     -> constante | ( E )
\end{lstlisting}


\subsection{Ajout de l'opérateur de puissance}
Ensuite, pour ajouter un opérateur de puissance, de telle sorte qu'il soit prioritaire sur la multiplication (mais pas les parenthèses) et associatif à droite, on ajoute une fonction supplémentaire entre les facteurs et les atomes. Comme elle utilise la récursivité droite, on n'a pas à la transformer comme les précédentes. On obtient donc la grammaire : 
\begin{lstlisting}[escapeinside={!}{!}]
E     -> F E_aux
E_aux -> + F E_aux | - F E_aux | !$\epsilon$!
F     -> P F_aux
F_aux -> * P F_aux | / P F_aux | !$\epsilon$!
P -> A ^ P | A
A     -> constante | ( E )
\end{lstlisting}

\subsection{Changement de la règle de puissance}
Cependant, la documentation des \texttt{stream parsers} précise qu'on ne peut pas commencer deux schémas de la même manière. Or, \texttt{P} se décompose en \texttt{A \^ P} ou \texttt{A}, qui commencent tous deux par \texttt{A}. On peut utiliser les paramètres d'exception \texttt{Stream.error} pour se rendre compte qu'en effet, l'analyse descendante attendra le reste de la règle (\texttt{\^ P}) même si on devrait utiliser le deuxième schéma de \texttt{P}.

Pour résoudre ce problème, on décompose la règle en deux règles :
\begin{lstlisting}[escapeinside={!}{!}]
P     -> A P_aux
P_aux -> ^ P | !$\epsilon$!
\end{lstlisting}

\subsection{Grammaire finale}
Ainsi, la grammaire obtenue est :
\begin{lstlisting}[escapeinside={!}{!}]
E     -> F E_aux
E_aux -> + F E_aux | - F E_aux | !$\epsilon$!
F     -> P F_aux
F_aux -> * P F_aux | / P F_aux | !$\epsilon$!
P     -> A P_aux
P_aux -> ^ P | !$\epsilon$!
A     -> constante | ( E )
\end{lstlisting}
 

\section{Implémentation}
La grammaire obtenue n'a plus qu'à être recopiée avec la syntaxe des \texttt{stream parsers}. 

On notera tout de même qu'il convient d'envoyer en argument l'expression déjà lue par une fonction principale aux fonctions auxiliaires, qui en auront besoin pour construire l'expression. 
% il me faut un exeple ici 

\section{Vérification}
Une fois le parseur implémenté, nous avons souhaité le tester pour vérifier sa correction.
Dans un premier temps, nous avons vérifié chaque associativité, chaque priorité en donnant divers exemples. Mais nous avons souhaité automatiser le processus de vérification.


Ainsi, nous avons donc un évaluateur, qui à partir d'une expression (sous forme d'arbre syntaxique abstrait), calcule le résultat.

Dans un second temps, nous avons créé un générateur aléatoire d'expressions arithmétiques (sous forme de chaînes de caractères) en \texttt{Ocaml}.
%détailler le générateur

Enfin, un programme en \texttt{bash} appelle le générateur et récupère une chaîne de caractères. Puis cette chaîne de caractère est scannée, analysée puis évaluée par notre parseur. D'un autre côté, on évalue également l'expression en \texttt{Python} (qui utilise les mêmes priorités et associativité que celles de notre parseur). Enfin, on compare les résultats.


La vérification automatique nous a permis de ... % à faire

Comme l'évaluateur de \texttt{Python} et notre évaluateur en \texttt{Ocaml} ne gèrent pas de la même manière les dépassements mémoire, il nous arrive d'avoir des résultats divergents lorsque le résultat (ou des sous-résultats) dépassent la capacité maximale de nos entiers. 

% arrondi

% division


Il ne s'agit pas d'une vérification exhaustive de toutes les expressions correctes que pourraient analyser notre parseur. En effet, nous avons ajouté des conditions de profondeur maximale dans la génération d'une expression, pour éviter les dépassements mémoires la plupart du temps. Cependant

\section{Conclusion}
Pour réaliser ce parseur, il nous a fallu nous intéresser au fonctionnement de l'analyse descendante, pour adapter nos règles à la méthode utilisée (pas de récursivités gauches par exemple). Il a fallu également s'adapter à l'outil utilisé, les \texttt{stream parsers} de \texttt{Camlp4} (pas de schémas qui commencent par la même séquence).

Le développement d'un outil de vérification empirique nous a permis de nous rendre compte de certais problèmes dans notre implémentation, et de nous convaincre de sa robustesse.




\end{document}
