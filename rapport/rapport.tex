\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amsfonts,amssymb}
%\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}

\title{DM COMP}
\author{Aurèle Barrière \& Antonin Garret}
\date{29 septembre 2016}

\begin{document}
\maketitle

\section{Introduction}


\section{Une grammaire pour des expressions arithmétiques}
\subsection{Une première version}
\begin{lstlisting}
E -> E + F | E - F | F
F -> F * A | A
A -> constante | ( E )
\end{lstlisting}
Expliquer priorité, mutuellement récursive.

Expliquer associativité gauche de toutes les opérations.

\subsection{Ajout de la division}
Même priorité que la multiplication.
\begin{lstlisting}
E -> E + F | E - F | F
F -> F * A | F / A | A
A -> constante | ( E )
\end{lstlisting}

\subsection{Récursivités gauches}
Analyse descendante.

Rappeler la méthode pour enlever réc. gauches.

\begin{lstlisting}[escapeinside={!}{!}]
E     -> F E_aux
E_aux -> + F E_aux | - F E_aux | !$\epsilon$!
F     -> P F_aux
F_aux -> * A F_aux | / A F_aux | !$\epsilon$!
A     -> constante | ( E )
\end{lstlisting}
C'est ce qu'on a de déjà implémenté.

\subsection{Ajout de l'opérateur de puissance}
Ajout entre les facteurs et les atomes : priorité.

Récursivité droite pour associativité droite.

On a donc 
\begin{lstlisting}[escapeinside={!}{!}]
E     -> F E_aux
E_aux -> + F E_aux | - F E_aux | !$\epsilon$!
F     -> P F_aux
F_aux -> * P F_aux | / P F_aux | !$\epsilon$!
P -> A ^ P | A
A     -> constante | ( E )
\end{lstlisting}

\subsection{Changement de la règle de puissance}
Dû à l'implémentation : deux règles ne peuvent pas commencer par le même élément et P se réduit en \lstinline{ A ^ P | A} qui commencent tous les deux par A.

On remplace donc la règle par 
\begin{lstlisting}[escapeinside={!}{!}]
P     -> A P_aux
P_aux -> ^ P | !$\epsilon$!
\end{lstlisting}

\subsection{Grammaire finale}
\begin{lstlisting}[escapeinside={!}{!}]
E     -> F E_aux
E_aux -> + F E_aux | - F E_aux | !$\epsilon$!
F     -> P F_aux
F_aux -> * P F_aux | / P F_aux | !$\epsilon$!
P     -> A P_aux
P_aux -> ^ P | !$\epsilon$!
A     -> constante | ( E )
\end{lstlisting}
 

\section{Implémentation}
Quelques mots sur stream parsers.

Préciser pourquoi on envoie e1 en argument aux fonctions auxiliaires.

\section{Tests}
Automatiser ?

Gestion d'erreurs? Stream parsers reconnaissent le début d'une expression correcte et s'en satisfont. Ca peut etre le rôle d'autre chose je ne suis pas sur.

\section{Conclusion}



\end{document}
